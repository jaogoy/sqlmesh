"""
Test unified model parameter vs physical_properties handling in StarRocks.

This test verifies the priority strategy:
1. Model parameter takes priority if present
2. Otherwise, use value from physical_properties
3. Ensure at most one definition exists
4. PRIMARY KEY is handled by base class, not in _build_table_key_property
"""
import pytest
from sqlglot import exp, parse_one
from sqlmesh.core.engine_adapter.starrocks import StarRocksEngineAdapter
from unittest.mock import MagicMock, patch


@pytest.fixture
def adapter():
    """Create a StarRocks adapter for testing."""
    connection = MagicMock()
    return StarRocksEngineAdapter(connection)


class TestUnifiedParameterHandling:
    """Test unified handling of model parameters vs physical_properties."""

    def test_primary_key_from_model_parameter(self, adapter):
        """Test PRIMARY KEY from model parameter takes priority."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.sales',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'amount': exp.DataType.build('DECIMAL(10,2)')
                },
                primary_key=('id', 'dt'),  # Model parameter
                table_properties={
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)")
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[PRIMARY KEY Model Param] Generated SQL:\n{sql}\n")

            # Verify PRIMARY KEY is generated by base class
            assert 'PRIMARY KEY' in sql.upper()
            assert 'id' in sql and 'dt' in sql
            # Verify column order: key columns first
            assert sql.index('id') < sql.index('amount')

    def test_primary_key_from_physical_properties(self, adapter):
        """Test PRIMARY KEY from physical_properties works."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.sales',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'amount': exp.DataType.build('DECIMAL(10,2)')
                },
                # No model parameter
                table_properties={
                    'primary_key': exp.Tuple(expressions=[
                        exp.Column(this='id'),
                        exp.Column(this='dt')
                    ]),
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)")
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[PRIMARY KEY Physical Prop] Generated SQL:\n{sql}\n")

            assert 'PRIMARY KEY' in sql.upper()
            assert 'id' in sql and 'dt' in sql

    def test_duplicate_key_from_physical_properties_only(self, adapter):
        """Test DUPLICATE KEY (only available via physical_properties)."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.events',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'event_type': exp.DataType.build('VARCHAR(100)')
                },
                table_properties={
                    'duplicate_key': exp.Tuple(expressions=[
                        exp.Column(this='id'),
                        exp.Column(this='dt')
                    ]),
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)")
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[DUPLICATE KEY] Generated SQL:\n{sql}\n")

            # DUPLICATE KEY should be in PROPERTIES, not as inline constraint
            assert 'DUPLICATE KEY' in sql.upper()
            # Verify column order
            assert sql.index('id') < sql.index('event_type')

    def test_partitioned_by_model_parameter_priority(self, adapter):
        """Test partitioned_by model parameter takes priority over physical_properties."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.sales',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'event_date': exp.DataType.build('DATE'),
                    'amount': exp.DataType.build('DECIMAL(10,2)')
                },
                primary_key=('id', 'dt'),
                partitioned_by=[exp.Column(this='dt')],  # Model parameter
                table_properties={
                    'partitioned_by': [exp.Column(this='event_date')],  # Should be ignored
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)")
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[PARTITION Model Param Priority] Generated SQL:\n{sql}\n")

            # Should use dt from model parameter, not event_date
            assert 'PARTITION BY' in sql.upper()
            # The exact syntax varies, but dt should be in partition clause

    def test_partitioned_by_from_physical_properties_fallback(self, adapter):
        """Test partitioned_by from physical_properties when no model parameter."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.sales',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'amount': exp.DataType.build('DECIMAL(10,2)')
                },
                primary_key=('id', 'dt'),
                # No model parameter
                table_properties={
                    'partitioned_by': [exp.Column(this='dt')],  # Fallback
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)")
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[PARTITION Physical Prop Fallback] Generated SQL:\n{sql}\n")

            assert 'PARTITION BY' in sql.upper()

    def test_clustered_by_model_parameter_priority(self, adapter):
        """Test clustered_by model parameter takes priority."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.sales',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'amount': exp.DataType.build('DECIMAL(10,2)')
                },
                primary_key=('id', 'dt'),
                clustered_by=[exp.Column(this='dt'), exp.Column(this='id')],  # Model parameter
                table_properties={
                    'order_by': [exp.Column(this='id')],  # Should be ignored
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)")
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[CLUSTERED_BY Model Param Priority] Generated SQL:\n{sql}\n")

            # Should use dt, id from model parameter
            assert 'ORDER BY' in sql.upper()

    def test_clustered_by_from_physical_properties_fallback(self, adapter):
        """Test clustered_by from physical_properties when no model parameter."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.sales',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'amount': exp.DataType.build('DECIMAL(10,2)')
                },
                primary_key=('id', 'dt'),
                # No model parameter
                table_properties={
                    'order_by': [exp.Column(this='dt'), exp.Column(this='id')],  # Fallback
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)")
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[CLUSTERED_BY Physical Prop Fallback] Generated SQL:\n{sql}\n")

            assert 'ORDER BY' in sql.upper()

    def test_comprehensive_unified_handling(self, adapter):
        """Test comprehensive scenario with all parameter types."""
        with patch.object(adapter, 'execute') as mock_execute:
            adapter._create_table_from_columns(
                table_name='test.comprehensive',
                target_columns_to_types={
                    'id': exp.DataType.build('INT'),
                    'dt': exp.DataType.build('DATE'),
                    'event_type': exp.DataType.build('VARCHAR(100)'),
                    'amount': exp.DataType.build('DECIMAL(10,2)')
                },
                # Model parameters (all take priority)
                primary_key=('id', 'dt'),
                partitioned_by=[exp.Column(this='dt')],
                clustered_by=[exp.Column(this='dt'), exp.Column(this='id')],
                table_properties={
                    # These should be used
                    'distributed_by': parse_one("(kind='HASH', expressions=id, buckets=10)"),
                    'replication_num': exp.Literal.number(1),
                    # These should be ignored (model params take priority)
                    'partitioned_by': [exp.Column(this='event_type')],  # Ignored
                    'order_by': [exp.Column(this='amount')],  # Ignored
                }
            )

            sql = mock_execute.call_args[0][0].sql(dialect='starrocks')
            print(f"\n[Comprehensive Unified] Generated SQL:\n{sql}\n")

            # Verify all components
            assert 'PRIMARY KEY' in sql.upper()
            assert 'PARTITION BY' in sql.upper()
            assert 'ORDER BY' in sql.upper()
            assert 'DISTRIBUTED BY' in sql.upper()
            assert 'PROPERTIES' in sql.upper()


if __name__ == '__main__':
    # Run with pytest
    pytest.main([__file__, '-v', '-s'])
